
## 1001.害死人不偿命的(3n+1)猜想(15分)
### 卡拉兹(`Callatz`)猜想：

对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把`(3n+1)`砍掉一半。这样一直反复砍下去，最后一定在某一步得到 `n=1`。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 `(3n+1)`，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……

我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 `1000` 的正整数 `n`，简单地数一下，需要多少步（砍几下）才能得到 `n=1`？

- 输入格式：
每个测试输入包含 `1` 个测试用例，即给出正整数 `n` 的值。

- 输出格式：
输出从 `n` 计算到 `1` 需要的步数。

- 输入样例：

```
3
```

- 输出样例：

```
5
```

### 第一次提交

```c
#include<stdio.h>
#include<stdbool.h>
bool odd(int n);
bool even(int n);

int main(void) {
    int i = 0, j = 0;
    int n;
    //     while(1){
    //         if(!scanf("%d:", &n) && n>=1000 && n<=0)
    //             printf("Please input an legal integer num:\n");
    //         }
         scanf("%d", &n);
    //if (scanf("%d", &n)) {};
    //初始输入为偶数
    if (even(n)) {
        //         for(int i = 1; n==1; i++)
        while (n != 1) {
            n /= 2;
            i++;
        }
        //         return i;
        printf("%d", i);
    }
    else {
        //奇数处理
        while (n != 1 || !odd(n)) {
            n = (n * 3 + 1) / 2;
            j++;
        }
        //中间出现偶数后处理
        while (n != 1) {
            n /= 2;
            j++;
        }
        //         return j;
        printf("%d", j);
    }
}

bool odd(int n) {
    if (n % 2 == 1)
        return 1;
    else
        return 0;
}
bool even(int n) {
    if (n % 2 == 0)
        return 1;
    else
        return 0;
}

```